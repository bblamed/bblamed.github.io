<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ðŸŽ¨ Bold Drawing Board</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@600&display=swap');
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: 'Poppins', sans-serif;
      background: #121212;
      color: #eee;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    header {
      padding: 1rem 1.5rem;
      font-size: 1.8rem;
      font-weight: 700;
      text-align: center;
      background: #1f1f1f;
      user-select: none;
      letter-spacing: 1.1px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.8);
      z-index: 10;
    }
    #toolbar {
      background: #222;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.7rem 1rem;
      gap: 1rem;
      flex-wrap: wrap;
      user-select: none;
      box-shadow: inset 0 -1px 0 #444;
    }
    #toolbar > * {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      color: #ddd;
      font-weight: 600;
      font-size: 0.95rem;
    }
    #toolbar input[type=color],
    #toolbar input[type=range],
    #toolbar select,
    #toolbar button {
      border-radius: 6px;
      border: none;
      outline: none;
      cursor: pointer;
      font-size: 1rem;
      padding: 0.3rem 0.5rem;
      background: #333;
      color: #eee;
      transition: background 0.2s;
    }
    #toolbar input[type=range] {
      width: 90px;
    }
    #toolbar input[type=color] {
      width: 38px;
      height: 32px;
      padding: 0;
      border: 2px solid #555;
    }
    #toolbar button:hover,
    #toolbar select:hover,
    #toolbar input[type=color]:hover {
      background: #555;
    }
    #canvas {
      flex-grow: 1;
      display: block;
      background: white;
      cursor: crosshair;
      box-shadow: inset 0 0 8px #999;
      touch-action: none;
      margin: 0 auto;
      max-width: 100vw;
      max-height: calc(100vh - 120px);
    }
    #colorImage {
      max-width: 120px;
      max-height: 60px;
      border: 2px solid #444;
      border-radius: 8px;
      cursor: crosshair;
      user-select: none;
      image-rendering: pixelated;
      filter: saturate(150%);
      box-shadow: 0 0 10px rgba(255,255,255,0.15);
    }
  </style>
</head>
<body>

<header>ðŸŽ¨ Bold Drawing Board</header>

<div id="toolbar">
  <label for="brushType">Brush:</label>
  <select id="brushType" title="Choose brush type">
    <option value="round">Round</option>
    <option value="square">Square</option>
    <option value="dots">Dotted</option>
    <option value="fill">Fill</option>
  </select>

  <label for="brushSize">Size:</label>
  <input type="range" id="brushSize" min="1" max="50" value="8" title="Brush size" />

  <label for="colorPicker">Color:</label>
  <input type="color" id="colorPicker" value="#000000" title="Pick color" />

  <img id="colorImage" src="https://i.imgur.com/0y8Ftya.jpg" alt="Pick color from this image" title="Click to pick color from image" />

  <button id="clearBtn" title="Clear canvas">Clear</button>
  <button id="saveBtn" title="Download your drawing">Download</button>
  <button id="fullscreenBtn" title="Toggle fullscreen">Fullscreen</button>
</div>

<canvas id="canvas" width="900" height="600" tabindex="0"></canvas>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const brushType = document.getElementById('brushType');
  const brushSize = document.getElementById('brushSize');
  const colorPicker = document.getElementById('colorPicker');
  const clearBtn = document.getElementById('clearBtn');
  const saveBtn = document.getElementById('saveBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const colorImage = document.getElementById('colorImage');

  let drawing = false;
  let lastX = 0;
  let lastY = 0;

  // Setup canvas for high-DPI screens
  function setupCanvas() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = canvas.clientWidth * dpr;
    canvas.height = canvas.clientHeight * dpr;
    ctx.scale(dpr, dpr);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
  }
  setupCanvas();

  // Get pointer coords relative to canvas
  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    if (e.touches && e.touches.length > 0) {
      return {
        x: e.touches[0].clientX - rect.left,
        y: e.touches[0].clientY - rect.top,
      };
    }
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    };
  }

  function startDraw(e) {
    e.preventDefault();
    const pos = getPos(e);
    drawing = true;
    lastX = pos.x;
    lastY = pos.y;

    if (brushType.value === 'fill') {
      floodFill(Math.floor(pos.x), Math.floor(pos.y), hexToRgb(colorPicker.value));
      drawing = false;
    }
  }

  function draw(e) {
    if (!drawing) return;
    e.preventDefault();
    const pos = getPos(e);

    ctx.strokeStyle = colorPicker.value;
    ctx.fillStyle = colorPicker.value;
    const size = brushSize.value;

    switch (brushType.value) {
      case 'round':
        ctx.lineWidth = size;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        break;
      case 'square':
        ctx.lineWidth = size;
        ctx.lineCap = 'butt';
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        break;
      case 'dots':
        // draw dots along the path
        let dist = Math.hypot(pos.x - lastX, pos.y - lastY);
        let steps = Math.floor(dist / (size / 2));
        for (let i = 0; i <= steps; i++) {
          let x = lastX + (pos.x - lastX) * (i / steps);
          let y = lastY + (pos.y - lastY) * (i / steps);
          ctx.beginPath();
          ctx.arc(x, y, size / 2, 0, Math.PI * 2);
          ctx.fill();
        }
        break;
      default:
        // fallback to round brush
        ctx.lineWidth = size;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
    }

    lastX = pos.x;
    lastY = pos.y;
  }

  function stopDraw(e) {
    drawing = false;
  }

  // Flood fill algorithm (simple 4-direction)
  function floodFill(startX, startY, fillColor) {
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;

    function colorMatch(x, y, color) {
      if (x < 0 || x >= w || y < 0 || y >= h) return false;
      const idx = (y * w + x) * 4;
      return (
        data[idx] === color.r &&
        data[idx + 1] === color.g &&
        data[idx + 2] === color.b &&
        data[idx + 3] === 255
      );
    }

    function setColor(x, y, color) {
      const idx = (y * w + x) * 4;
      data[idx] = color.r;
      data[idx + 1] = color.g;
      data[idx + 2] = color.b;
      data[idx + 3] = 255;
    }

    const startIdx = (startY * w + startX) * 4;
    const startColor = {
      r: data[startIdx],
      g: data[startIdx + 1],
      b: data[startIdx + 2],
    };

    // If the start pixel color is the same as fill color, do nothing
    if (
      startColor.r === fillColor.r &&
      startColor.g === fillColor.g &&
      startColor.b === fillColor.b
    ) {
      return;
    }

    const stack = [[startX, startY]];

    while (stack.length > 0) {
      const [x, y] = stack.pop();
      if (!colorMatch(x, y, startColor)) continue;
      setColor(x, y, fillColor);

      stack.push([x + 1, y]);
      stack.push([x - 1, y]);
      stack.push([x, y + 1]);
      stack.push([x, y - 1]);
    }

    ctx.putImageData(imageData, 0, 0);
  }

  // Convert hex color string to rgb object
  function hexToRgb(hex) {
    const cleanHex = hex.replace('#', '');
    const bigint = parseInt(cleanHex, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return { r, g, b };
  }

  // Toolbar button events
  clearBtn.addEventListener('click', () => {
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  });

  saveBtn.addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = 'bold_drawing.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  });

  fullscreenBtn.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      canvas.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  });

  // Pick color from image
  colorImage.addEventListener('click', (e) => {
    const rect = colorImage.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = colorImage.naturalWidth;
    tempCanvas.height = colorImage.naturalHeight;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(colorImage, 0, 0);

    const scaleX = colorImage.naturalWidth / rect.width;
    const scaleY = colorImage.naturalHeight / rect.height;

    const pixel = tempCtx.getImageData(Math.floor(x * scaleX), Math.floor(y * scaleY), 1, 1).data;
    const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);
    colorPicker.value = hex;
  });

  // Convert rgb to hex string
  function rgbToHex(r, g, b) {
    return "#" + [r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    }).join('');
  }

  // Drawing event listeners
  canvas.addEventListener('mousedown', startDraw);
  canvas.addEventListener('touchstart', startDraw);

  canvas.addEventListener('mousemove', draw);
  canvas.addEventListener('touchmove', draw);

  canvas.addEventListener('mouseup', stopDraw);
  canvas.addEventListener('mouseleave', stopDraw);
  canvas.addEventListener('touchend', stopDraw);
  canvas.addEventListener('touchcancel', stopDraw);

  // Resize canvas to fill horizontally on window resize, keep aspect ratio
  function resizeCanvas() {
    const containerWidth = window.innerWidth;
    const containerHeight = window.innerHeight - document.querySelector('header').offsetHeight - document.getElementById('toolbar').offsetHeight;

    canvas.style.width = containerWidth + 'px';
    canvas.style.height = containerHeight + 'px';

    setupCanvas();
  }

  window.addEventListener('resize', resizeCanvas);
  window.addEventListener('load', resizeCanvas);

</script>

</body>
</html>
